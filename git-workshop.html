<slides>
# ![](https://git-scm.com/images/logos/downloads/Git-Logo-2Color.png)
--
# The basics
--
## What is a `commit`?
--
## `git add . && git commit`

![](https://i.stack.imgur.com/naws3.png =500x300)
--
## What is a `branch`?

![](https://buddy.works/blog/images/feature-branch.png)
--
## What is `origin`?
--
## `fetch` vs `pull`
--
# Working with branches
--
## `checkout` vs `reset`
--
## `merge` vs `rebase`
--
## `merge` vs `merge --squash`
--
## How do I deal with conflicts?
	git fetch
	git merge origin/master
	git status
	vim blah
	git add blah
	git commit -m "Merge master"
	git checkout master
	git merge MyBranch --squash`
--
# Practices
--
## What is a reasonable commit? 
1. Standalone
2. Testable
2. Explainable
3. Not too big
--
## How often should commit? 
Private commits vs public commits
--
1. Separate subject from body with a blank line
2. Limit the subject line to 50 characters
3. Capitalize the subject line
4. Do not end the subject line with a period
5. Use the imperative mood in the subject line
6. Use the body to explain what and why vs. how
--
	Make Source.indexOf(ByteString) significantly faster
	
	Previously the algorithm that did this was extremely inefficient, and 
	had worst case runtime of O(N * S * S) for N is size of the bytestring 
	and S is the number of segments.

	The new code runs in O(N * S). It accomplishes this by not starting 
	each search at the first segment, which could occur many times when 
	called by RealBufferedSource.
--
# Optional topics
--
## Selective staging 

`add -p`
--
## Changing history 

`commit --amend`
--
## *Really* Changing history 

`rebase -i`
--
# Questions?
</slides>

<html>
		<head>
				<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
				<title>Git workshop</title>
				<meta name="robots" content="noindex, nofollow" />
				<meta name="googlebot" content="noindex, nofollow" />
				<meta name="viewport" content="width=device-width, initial-scale=1" />
				<script src="./showdown.min.js"></script>
				<link href="https://fonts.googleapis.com/css?family=Noto+Serif+TC|Roboto+Mono" rel="stylesheet" />
				<style type="text/css">
						body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td {
							margin:0;
							padding:0;
						}

						html, body, #root, #slide {
								height: 100%;
								width: 100%;
								background-color: white;
						}

						body {
								font-size: 2rem;
								font-family: "Noto Serif TC", "Palatino Linotype", "Book Antiqua", Palatino, serif;
						}

						h1 {
								font-size: 5rem;
						}

						h2 {
								font-size: 3rem;
						}
						
						#slide {
								display: flex;
								flex-direction: column;
								align-items: center;
								justify-content: space-evenly;
						}

						slides {
							display: none
						}

						.logo {
								position: absolute;
								right: 0;
								bottom: 0;
								height: 4rem;
								margin: 1rem;
						}

						pre, code {
								color: green;
								padding: 1rem;
								font-family: "Roboto Mono", "Lucida Console", Monaco, monospace;
								border: 5px dashed green;
						}

						pre code {
							border: 0;
							padding: 0;
						}

						blockquote {
								color: green;
						}

				</style>

				<script type="application/javascript" >
						class Presenter {
							constructor(root) {
								this.state = {page: 0};
								this.root = root;
								this.root.onkeydown = (ev => this.handleKeyPress(ev));
								const content = document.getElementsByTagName('slides')[0];
								this.slides = content.innerText.split('\n--\n')
								this.converter = new showdown.Converter();
							}

							toggleFullScreen(element) {

								if (
									!document.fullscreenElement &&
									!document.mozFullScreenElement &&
									!document.webkitFullscreenElement &&
									!document.msFullscreenElement
								) {
									// current working methods
									if (element.requestFullscreen) {
										element.requestFullscreen();
									} else if (element.msRequestFullscreen) {
										element.msRequestFullscreen();
									} else if (element.mozRequestFullScreen) {
										element.mozRequestFullScreen();
									} else if (element.webkitRequestFullscreen) {
										element.webkitRequestFullscreen();
									}
								} else {
									if (document.exitFullscreen) {
										document.exitFullscreen();
									} else if (document.msExitFullscreen) {
										document.msExitFullscreen();
									} else if (document.mozCancelFullScreen) {
										document.mozCancelFullScreen();
									} else if (document.webkitExitFullscreen) {
										document.webkitExitFullscreen();
									}
								}
							}

							setState(obj) {
								for (var key in obj) {
									this.state[key] = obj[key]
								}
								this.render()
							}


							handleKeyPress(e) {
								console.log(e.key)
								switch (e.key) {
									case "ArrowRight":
										this.setState({
											page: Math.min(this.slides.length - 1, this.state.page + 1),
										});
										return;
									case "ArrowLeft":
										this.setState({ page: Math.max(0, this.state.page - 1) });
										return;
									case "f":
										this.toggleFullScreen(this.root);
								}
							}

							makeSlideHtml(slide) {
								const html = this.converter.makeHtml(slide);
								return `<div id="slide">${html}</div>`;
							}

							render() {
								this.root.innerHTML = this.makeSlideHtml(this.slides[this.state.page])
							}
						}
				
				function run() {
					const root = document.getElementById("root")
					const presenter = new Presenter(root);
					root.focus()
					presenter.render()
				}
				</script>
		</head>

		<body onload="run()">
				<div id="root" tabindex="0"></div>
		</body>

</html>